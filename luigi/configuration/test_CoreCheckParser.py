# ********RoostGPT********
"""
Test generated by RoostGPT for test pythonBigProjectTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=_check_parser_a1d81ddd5b
ROOST_METHOD_SIG_HASH=_check_parser_326832c82e


Scenario 1: Test with Parser Class Disabled
Details:
  TestName: test_parser_disabled
  Description: This test verifies the behavior of the function when the parser_class is disabled. The function should throw an ImportError in this case.
Execution:
  Arrange: Disable the parser_class. Prepare a mock for the parser_class with enabled property set to False.
  Act: Call the _check_parser function with the disabled parser_class and any parser name.
  Assert: Check if the function raises an ImportError.
Validation:
  This test is important because it ensures the function behaves as expected when a parser is disabled, throwing an error to prevent further code execution.

Scenario 2: Test with Parser Class Enabled
Details:
  TestName: test_parser_enabled
  Description: This test verifies the behavior of the function when the parser_class is enabled. In this case, the function should not raise any error.
Execution:
  Arrange: Enable the parser_class. Prepare a mock for the parser_class with enabled property set to True.
  Act: Call the _check_parser function with the enabled parser_class and any parser name.
  Assert: Check if the function does not raise any errors.
Validation:
  This test ensures that the function works as expected when the parser is enabled, allowing the execution to proceed.

Scenario 3: Test the Error Message
Details:
  TestName: test_error_message
  Description: This test verifies the error message when the parser_class is not installed. The function should raise an ImportError with a specific message.
Execution:
  Arrange: Disable the parser_class. Prepare a mock for the parser_class with enabled property set to False.
  Act: Call the _check_parser function with the disabled parser_class and any parser name.
  Assert: Check if the function raises an ImportError with the correct error message.
Validation:
  This test is important because it ensures the function provides a clear and accurate error message when the parser_class is not installed, aiding debugging and troubleshooting.  

Scenario 4: Test with Different Parser Types
Details:
  TestName: test_different_parser_types
  Description: This test verifies the behavior of the function when invoked with different types of parsers (e.g., LuigiConfigParser, LuigiTomlParser). The function should behave consistently across different parser types.
Execution:
  Arrange: Prepare mocks for different parser_classes with enabled property set to True.
  Act: Call the _check_parser function with each parser_class and respective parser name.
  Assert: Check if the function does not raise any errors for any parser type.
Validation:
  This test ensures that the function supports different types of parsers, affirming its flexibility and robustness.
"""

# ********RoostGPT********
import logging
import os
import warnings
import pytest
from unittest.mock import Mock
from cfg_parser import LuigiConfigParser
from toml_parser import LuigiTomlParser
from core import _check_parser

class Test_CoreCheckParser:

    @pytest.mark.negative
    def test_parser_disabled(self):
        # Arrange
        mock_parser_class = Mock()
        mock_parser_class.enabled = False

        # Act & Assert
        with pytest.raises(ImportError):
            _check_parser(mock_parser_class, 'cfg')

    @pytest.mark.positive
    def test_parser_enabled(self):
        # Arrange
        mock_parser_class = Mock()
        mock_parser_class.enabled = True

        # Act & Assert
        try:
            _check_parser(mock_parser_class, 'cfg')
        except Exception as e:
            pytest.fail(f"Unexpected Error Occured: {e}")

    @pytest.mark.negative
    def test_error_message(self):
        # Arrange
        mock_parser_class = Mock()
        mock_parser_class.enabled = False
        expected_message = "Parser not installed yet. Please, install luigi with required parser:\npip install luigi[cfg]"

        # Act & Assert
        with pytest.raises(ImportError) as e_info:
            _check_parser(mock_parser_class, 'cfg')
        assert str(e_info.value) == expected_message

    @pytest.mark.positive
    def test_different_parser_types(self):
        # Arrange
        mock_parser_classes = [LuigiConfigParser, LuigiTomlParser]
        parser_names = ['cfg', 'toml']

        # Act & Assert
        for mock_parser_class, parser_name in zip(mock_parser_classes, parser_names):
            try:
                _check_parser(mock_parser_class, parser_name)
            except Exception as e:
                pytest.fail(f"Unexpected Error Occured: {e}")
