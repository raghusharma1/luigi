# ********RoostGPT********
"""
Test generated by RoostGPT for test pythonBigProjectTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=add_config_path_b37d083919
ROOST_METHOD_SIG_HASH=add_config_path_e4357e7904


Scenario 1: Validate config file existence
Details:
  TestName: test_add_config_path_file_existence
  Description: This test is intended to verify that the function correctly handles the case when the provided path does not refer to an existing file.
Execution:
  Arrange: Provide a path that does not refer to an existing file.
  Act: Call the add_config_path function with the prepared path.
  Assert: The function should return False and a warning about a non-existing file should be issued.
Validation:
  This test is crucial to ensure the function correctly handles invalid inputs and prevents further processing when a non-existing file is provided.

Scenario 2: Validate parser selection by file extension
Details:
  TestName: test_add_config_path_parser_selection
  Description: This test is intended to verify that the function correctly selects the parser based on the file extension.
Execution:
  Arrange: Provide a path to a file with a known extension that corresponds to one of the available parsers.
  Act: Call the add_config_path function with the prepared path.
  Assert: The function should not raise any exceptions and a warning should be issued if the selected parser differs from the default one. 
Validation:
  This is important to ensure that the function correctly selects the parser based on the file extension, which is a key part of its functionality.

Scenario 3: Validate behavior with an unsupported file extension
Details:
  TestName: test_add_config_path_unsupported_extension
  Description: This test is intended to verify that the function correctly handles the case when the file has an extension that does not correspond to any available parser.
Execution:
  Arrange: Provide a path to a file with an unsupported extension.
  Act: Call the add_config_path function with the prepared path.
  Assert: The function should select the default parser and a warning about an invalid parser should be issued.
Validation:
  This test is important to ensure the function can correctly fall back to the default parser when an unsupported file extension is provided, which is a key part of its error handling.

Scenario 4: Validate behavior when the parser is not enabled
Details:
  TestName: test_add_config_path_parser_not_enabled
  Description: This test is intended to verify that the function correctly handles the case when the selected parser is not enabled.
Execution:
  Arrange: Prepare the environment so that the selected parser is not enabled.
  Act: Call the add_config_path function with a path to a file with an extension that corresponds to the disabled parser.
  Assert: The function should raise an ImportError indicating that the parser is not installed.
Validation:
  This test is important to ensure the function correctly signals when a required parser is not available, which is a key part of its error handling.
"""

# ********RoostGPT********
import os
import warnings
import pytest
from unittest.mock import patch, MagicMock
from core import add_config_path, LuigiConfigParser, LuigiTomlParser

class Test_CoreAddConfigPath:

    @pytest.mark.regression
    def test_add_config_path_file_existence(self):
        with patch('os.path.isfile', return_value=False), patch('warnings.warn') as warn_mock:
            assert not add_config_path('non_existing_file')
            warn_mock.assert_called_once_with('Config file does not exist: non_existing_file')

    @pytest.mark.regression
    def test_add_config_path_parser_selection(self):
        with patch('os.path.isfile', return_value=True), patch('warnings.warn') as warn_mock:
            with patch('core._get_default_parser', return_value='cfg'), patch('core.LuigiConfigParser.add_config_path') as add_mock:
                assert add_config_path('config.cfg')
                warn_mock.assert_not_called()
                add_mock.assert_called_once_with('config.cfg')

    @pytest.mark.regression
    def test_add_config_path_unsupported_extension(self):
        with patch('os.path.isfile', return_value=True), patch('warnings.warn') as warn_mock:
            with patch('core._get_default_parser', return_value='cfg'), patch('core.LuigiConfigParser.add_config_path') as add_mock:
                assert add_config_path('config.unsupported')
                warn_mock.assert_called_once()
                add_mock.assert_called_once_with('config.unsupported')

    @pytest.mark.regression
    def test_add_config_path_parser_not_enabled(self):
        with patch('os.path.isfile', return_value=True):
            with patch('core._get_default_parser', return_value='toml'), patch('core.LuigiTomlParser.add_config_path') as add_mock:
                add_mock.side_effect = ImportError('Parser not installed yet. Please, install luigi with required parser:\npip install luigi[toml]')
                with pytest.raises(ImportError):
                    add_config_path('config.toml')
