# ********RoostGPT********
"""
Test generated by RoostGPT for test pythonBigProjectTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=add_config_path_388d3ffdb1
ROOST_METHOD_SIG_HASH=add_config_path_05e54720ac


Scenario 1: Verify the addition of a new config path.
Details:
  TestName: test_add_config_path
  Description: This test verifies if a new path can be added successfully to the config paths. 
Execution:
  Arrange: Initialize an instance of the class with a known set of config paths.
  Act: Call the add_config_path method with a new, unique path.
  Assert: Check if the new path is added to the list of config paths and the reload method is called.
Validation:
  The test ensures that the method can successfully add a new path to the config paths. This is crucial for the function's ability to manage multiple configurations.

Scenario 2: Verify the addition of an existing config path.
Details:
  TestName: test_add_existing_config_path
  Description: This test validates the behavior of the function when an existing path is added to the config paths.
Execution:
  Arrange: Initialize an instance of the class with a known set of config paths.
  Act: Call the add_config_path method with a path that already exists in the config paths.
  Assert: Check if the path is not duplicated in the list of config paths and the reload method is called.
Validation:
  The test checks if the function can handle the addition of an existing path without creating duplicates, maintaining the integrity of the config paths.

Scenario 3: Verify the addition of a null config path.
Details:
  TestName: test_add_null_config_path
  Description: This test examines the function's behavior when a null or empty path is added.
Execution:
  Arrange: Initialize an instance of the class with a known set of config paths.
  Act: Call the add_config_path method with a null or empty path.
  Assert: Check if the null or empty path is not added to the list of config paths and the reload method is not called.
Validation:
  This test is important to ensure that the function can handle invalid inputs gracefully without causing unexpected behavior.

Scenario 4: Verify the addition of a config path when reload fails.
Details:
  TestName: test_add_config_path_reload_fail
  Description: This test checks the function's behavior when the reload method fails after adding a new path.
Execution:
  Arrange: Initialize an instance of the class with a known set of config paths. Mock the reload method to throw an exception.
  Act: Call the add_config_path method with a new, unique path.
  Assert: Check if the new path is added to the list of config paths and an appropriate error is logged when the reload method fails.
Validation:
  This test ensures that the function can handle failures in the reload method gracefully and log appropriate errors.
"""

# ********RoostGPT********
import logging
import pytest
from configuration.base_parser import BaseParser
from unittest.mock import patch, call

class Test_BaseParserAddConfigPath:
    
    @pytest.mark.parametrize("new_path", ["new_path"])
    def test_add_config_path(self, new_path):
        base_parser = BaseParser()
        base_parser._config_paths = ["path1", "path2"]
        with patch.object(BaseParser, 'reload', return_value=None) as mock_reload:
            base_parser.add_config_path(new_path)
        mock_reload.assert_called_once()
        assert new_path in base_parser._config_paths

    @pytest.mark.parametrize("existing_path", ["path1"])
    def test_add_existing_config_path(self, existing_path):
        base_parser = BaseParser()
        base_parser._config_paths = ["path1", "path2"]
        with patch.object(BaseParser, 'reload', return_value=None) as mock_reload:
            base_parser.add_config_path(existing_path)
        mock_reload.assert_called_once()
        assert base_parser._config_paths.count(existing_path) == 1

    @pytest.mark.parametrize("null_path", ["", None])
    def test_add_null_config_path(self, null_path):
        base_parser = BaseParser()
        base_parser._config_paths = ["path1", "path2"]
        with patch.object(BaseParser, 'reload', return_value=None) as mock_reload:
            base_parser.add_config_path(null_path)
        mock_reload.assert_not_called()
        assert null_path not in base_parser._config_paths

    @pytest.mark.parametrize("new_path", ["new_path"])
    def test_add_config_path_reload_fail(self, new_path):
        base_parser = BaseParser()
        base_parser._config_paths = ["path1", "path2"]
        with patch.object(BaseParser, 'reload', side_effect=Exception("Reload failed")) as mock_reload, \
            patch.object(logging, 'error') as mock_log:
            base_parser.add_config_path(new_path)
        mock_reload.assert_called_once()
        mock_log.assert_called_once_with("Error reloading config: Reload failed")
        assert new_path in base_parser._config_paths
