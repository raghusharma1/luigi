# ********RoostGPT********
"""
Test generated by RoostGPT for test pythonBigProjectTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=get_3589554733
ROOST_METHOD_SIG_HASH=get_d2f3a08528


Scenario 1: Validating successful retrieval of option value with underscore style
Details:
  TestName: test_get_option_with_underscore
  Description: This test is intended to verify if the function successfully retrieves the value of the option using the underscore style.
Execution:
  Arrange: Initialize a ConfigParser object with a specific section and option-value pair.
  Act: Invoke the get function with the section and option as parameters.
  Assert: Check if the returned value matches the expected option value.
Validation:
  The test ensures that the function correctly retrieves the value of the option using the underscore style, which is the recommended style.

Scenario 2: Validating successful retrieval of option value with dash style
Details:
  TestName: test_get_option_with_dash
  Description: This test is intended to verify if the function successfully retrieves the value of the option using the dash style and issues a deprecation warning.
Execution:
  Arrange: Initialize a ConfigParser object with a specific section and option-value pair using dash style.
  Act: Invoke the get function with the section and option as parameters.
  Assert: Check if the returned value matches the expected option value and if a deprecation warning is issued.
Validation:
  The test ensures that the function retrieves the value of the option using the dash style and issues a deprecation warning, as this style should be avoided.

Scenario 3: Validating exception handling when the option is not found
Details:
  TestName: test_get_no_option
  Description: This test is intended to verify if the function raises a NoOptionError when the option is not found.
Execution:
  Arrange: Initialize a ConfigParser object with a specific section but without the required option.
  Act: Invoke the get function with the section and option as parameters.
  Assert: Check if a NoOptionError is raised.
Validation:
  The test ensures that the function correctly raises a NoOptionError when the option is not found, indicating a failure to retrieve the option.

Scenario 4: Validating exception handling when the default value type does not match the expected type
Details:
  TestName: test_get_mismatched_default_type
  Description: This test is intended to verify if the function raises an exception when the default value does not match the expected type.
Execution:
  Arrange: Initialize a ConfigParser object with a specific section and option, and a default value that does not match the expected type.
  Act: Invoke the get function with the section, option, and default value as parameters.
  Assert: Check if an exception is raised.
Validation:
  The test ensures that the function correctly raises an exception when the default value does not match the expected type, indicating a type mismatch error.
"""

# ********RoostGPT********
import os
import re
import warnings
import pytest
from configparser import ConfigParser, NoOptionError, NoSectionError, InterpolationError
from configparser import Interpolation, BasicInterpolation
from configuration.cfg_parser import LuigiConfigParser

class Test_LuigiConfigParserGet:
  
    @pytest.mark.valid
    def test_get_option_with_underscore(self):
        # Arrange
        config = ConfigParser()
        config.add_section('test')
        config.set('test', 'option_name', 'value')
        parser = LuigiConfigParser(config)
        
        # Act
        result = parser.get('test', 'option_name')
        
        # Assert
        assert result == 'value'

    @pytest.mark.valid
    def test_get_option_with_dash(self):
        # Arrange
        config = ConfigParser()
        config.add_section('test')
        config.set('test', 'option-name', 'value')
        parser = LuigiConfigParser(config)
        
        # Act
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            result = parser.get('test', 'option-name')
            
        # Assert
        assert len(w) == 1
        assert issubclass(w[-1].category, DeprecationWarning)
        assert "should be avoided" in str(w[-1].message)
        assert result == 'value'

    @pytest.mark.negative
    def test_get_no_option(self):
        # Arrange
        config = ConfigParser()
        config.add_section('test')
        parser = LuigiConfigParser(config)

        # Act and Assert
        with pytest.raises(NoOptionError):
            parser.get('test', 'option_name')

    @pytest.mark.invalid
    def test_get_mismatched_default_type(self):
        # Arrange
        config = ConfigParser()
        config.add_section('test')
        config.set('test', 'option_name', 'value')
        parser = LuigiConfigParser(config)

        # Act and Assert
        with pytest.raises(TypeError):
            parser.get('test', 'option_name', default=123)
